<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <title>PreProcessor - PythiaSource</title>
  

  <link rel="shortcut icon" href="../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">

  
  <script>
    // Current page data
    var mkdocs_page_name = "PreProcessor";
    var mkdocs_page_input_path = "typedpython.md";
    var mkdocs_page_url = "/typedpython/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script>
  <script src="../js/theme.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> PythiaSource</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="..">Home</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../generatorbase/">MultiBackendBaseClass</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../jstranslator/">JavascriptTranslator</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../gotranslator/">GolangTranslator</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../cpprustbase/">SharedRustC++Class</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../cpptranslator/">C++Translator</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="./">PreProcessor</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#simple-syntax-test">Simple Syntax Test</a></li>
                
            
            </ul>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../intermediateform/">PreTranslator</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">PythiaSource</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>PreProcessor</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="https://github.com/secureosv/pythia" class="icon icon-github"> Edit on GitHub</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <pre><code class="python">
USE_UNICODE_VARS = '--literate-unicode' in sys.argv
OBFUSCATE_UNICODE = '--obfuscate' in sys.argv

ObfuscationMap = {}  ## unichar : random string

MathematicalAlphabet = {
    u'ğ€' : 'A',
    u'ğ' : 'B',
    u'ğ‚' : 'C',
    u'ğƒ' : 'D',
    u'ğ„' : 'E',
    u'ğ…' : 'F',
    u'ğ†' : 'G',
    u'ğ‡' : 'H',
    u'ğˆ' : 'I',
    u'ğ‰' : 'J',
    u'ğŠ' : 'K',
    u'ğ‹' : 'L',
    u'ğŒ' : 'M',
    u'ğ' : 'N',
    u'ğ' : 'O',
    u'ğ' : 'P',
    u'ğ' : 'Q',
    u'ğ‘' : 'R',
    u'ğ’' : 'S',
    u'ğ“' : 'T',
    u'ğ”' : 'U',
    u'ğ•' : 'V',
    u'ğ–' : 'W',
    u'ğ—' : 'X',
    u'ğ˜' : 'Y',
    u'ğ™' : 'Z',
    u'ğš' : 'a',
    u'ğ›' : 'b',
    u'ğœ' : 'c',
    u'ğ' : 'd',
    u'ğ' : 'e',
    u'ğŸ' : 'f',
    u'ğ ' : 'g',
    u'ğ¡' : 'h',
    u'ğ¢' : 'i',
    u'ğ£' : 'j',
    u'ğ¤' : 'k',
    u'ğ¥' : 'l',
    u'ğ¦' : 'm',
    u'ğ§' : 'n',
    u'ğ¨' : 'o',
    u'ğ©' : 'p',
    u'ğª' : 'q',
    u'ğ«' : 'r',
    u'ğ¬' : 's',
    u'ğ­' : 't',
    u'ğ®' : 'u',
    u'ğ¯' : 'v',
    u'ğ°' : 'w',
    u'ğ±' : 'x',
    u'ğ²' : 'y',
    u'ğ³' : 'z',
    u'ğ´' : 'A',
    u'ğµ' : 'B',
    u'ğ¶' : 'C',
    u'ğ·' : 'D',
    u'ğ¸' : 'E',
    u'ğ¹' : 'F',
    u'ğº' : 'G',
    u'ğ»' : 'H',
    u'ğ¼' : 'I',
    u'ğ½' : 'J',
    u'ğ¾' : 'K',
    u'ğ¿' : 'L',
    u'ğ‘€' : 'M',
    u'ğ‘' : 'N',
    u'ğ‘‚' : 'O',
    u'ğ‘ƒ' : 'P',
    u'ğ‘„' : 'Q',
    u'ğ‘…' : 'R',
    u'ğ‘†' : 'S',
    u'ğ‘‡' : 'T',
    u'ğ‘ˆ' : 'U',
    u'ğ‘‰' : 'V',
    u'ğ‘Š' : 'W',
    u'ğ‘‹' : 'X',
    u'ğ‘Œ' : 'Y',
    u'ğ‘' : 'Z',
    u'ğ‘' : 'a',
    u'ğ‘' : 'b',
    u'ğ‘' : 'c',
    u'ğ‘‘' : 'd',
    u'ğ‘’' : 'e',
    u'ğ‘“' : 'f',
    u'ğ‘”' : 'g',
    u'ğ‘–' : 'i',
    u'ğ‘—' : 'j',
    u'ğ‘˜' : 'k',
    u'ğ‘™' : 'l',
    u'ğ‘š' : 'm',
    u'ğ‘›' : 'n',
    u'ğ‘œ' : 'o',
    u'ğ‘' : 'p',
    u'ğ‘' : 'q',
    u'ğ‘Ÿ' : 'r',
    u'ğ‘ ' : 's',
    u'ğ‘¡' : 't',
    u'ğ‘¢' : 'u',
    u'ğ‘£' : 'v',
    u'ğ‘¤' : 'w',
    u'ğ‘¥' : 'x',
    u'ğ‘¦' : 'y',
    u'ğ‘§' : 'z',
    u'ğ‘¨' : 'A',
    u'ğ‘©' : 'B',
    u'ğ‘ª' : 'C',
    u'ğ‘«' : 'D',
    u'ğ‘¬' : 'E',
    u'ğ‘­' : 'F',
    u'ğ‘®' : 'G',
    u'ğ‘¯' : 'H',
    u'ğ‘°' : 'I',
    u'ğ‘±' : 'J',
    u'ğ‘²' : 'K',
    u'ğ‘³' : 'L',
    u'ğ‘´' : 'M',
    u'ğ‘µ' : 'N',
    u'ğ‘¶' : 'O',
    u'ğ‘·' : 'P',
    u'ğ‘¸' : 'Q',
    u'ğ‘¹' : 'R',
    u'ğ‘º' : 'S',
    u'ğ‘»' : 'T',
    u'ğ‘¼' : 'U',
    u'ğ‘½' : 'V',
    u'ğ‘¾' : 'W',
    u'ğ‘¿' : 'X',
    u'ğ’€' : 'Y',
    u'ğ’' : 'Z',
    u'ğ’‚' : 'a',
    u'ğ’ƒ' : 'b',
    u'ğ’„' : 'c',
    u'ğ’…' : 'd',
    u'ğ’†' : 'e',
    u'ğ’‡' : 'f',
    u'ğ’ˆ' : 'g',
    u'ğ’‰' : 'h',
    u'ğ’Š' : 'i',
    u'ğ’‹' : 'j',
    u'ğ’Œ' : 'k',
    u'ğ’' : 'l',
    u'ğ’' : 'm',
    u'ğ’' : 'n',
    u'ğ’' : 'o',
    u'ğ’‘' : 'p',
    u'ğ’’' : 'q',
    u'ğ’“' : 'r',
    u'ğ’”' : 's',
    u'ğ’•' : 't',
    u'ğ’–' : 'u',
    u'ğ’—' : 'v',
    u'ğ’˜' : 'w',
    u'ğ’™' : 'x',
    u'ğ’š' : 'y',
    u'ğ’›' : 'z',
    u'ğ’œ' : 'A',
    u'ğ’' : 'C',
    u'ğ’Ÿ' : 'D',
    u'ğ’¢' : 'G',
    u'ğ’¥' : 'J',
    u'ğ’¦' : 'K',
    u'ğ’©' : 'N',
    u'ğ’ª' : 'O',
    u'ğ’«' : 'P',
    u'ğ’¬' : 'Q',
    u'ğ’®' : 'S',
    u'ğ’¯' : 'T',
    u'ğ’°' : 'U',
    u'ğ’±' : 'V',
    u'ğ’²' : 'W',
    u'ğ’³' : 'X',
    u'ğ’´' : 'Y',
    u'ğ’µ' : 'Z',
    u'ğ’¶' : 'a',
    u'ğ’·' : 'b',
    u'ğ’¸' : 'c',
    u'ğ’¹' : 'd',
    u'ğ’»' : 'f',
    u'ğ’»ğ’½' : 'h',
    u'ğ’¾' : 'i',
    u'ğ’¿' : 'j',
    u'ğ“€' : 'k',
    u'ğ“' : 'l',
    u'ğ“‚' : 'm',
    u'ğ“ƒ' : 'n',
    u'ğ“…' : 'p',
    u'ğ“†' : 'q',
    u'ğ“‡' : 'r',
    u'ğ“ˆ' : 's',
    u'ğ“‰' : 't',
    u'ğ“Š' : 'u',
    u'ğ“‹' : 'v',
    u'ğ“Œ' : 'w',
    u'ğ“' : 'x',
    u'ğ“' : 'y',
    u'ğ“' : 'z',
    u'ğ“' : 'A',
    u'ğ“‘' : 'B',
    u'ğ“’' : 'C',
    u'ğ““' : 'D',
    u'ğ“”' : 'E',
    u'ğ“•' : 'F',
    u'ğ“–' : 'G',
    u'ğ“—' : 'H',
    u'ğ“˜' : 'I',
    u'ğ“™' : 'J',
    u'ğ“š' : 'K',
    u'ğ“›' : 'L',
    u'ğ“œ' : 'M',
    u'ğ“' : 'N',
    u'ğ“' : 'O',
    u'ğ“Ÿ' : 'P',
    u'ğ“ ' : 'Q',
    u'ğ“¡' : 'R',
    u'ğ“¢' : 'S',
    u'ğ“£' : 'T',
    u'ğ“¤' : 'U',
    u'ğ“¥' : 'V',
    u'ğ“¦' : 'W',
    u'ğ“§' : 'X',
    u'ğ“¨' : 'Y',
    u'ğ“©' : 'Z',
    u'ğ“ª' : 'a',
    u'ğ“«' : 'b',
    u'ğ“¬' : 'c',
    u'ğ“­' : 'd',
    u'ğ“®' : 'e',
    u'ğ“¯' : 'f',
    u'ğ“°' : 'g',
    u'ğ“±' : 'h',
    u'ğ“²' : 'i',
    u'ğ“³' : 'j',
    u'ğ“´' : 'k',
    u'ğ“µ' : 'l',
    u'ğ“¶' : 'm',
    u'ğ“·' : 'n',
    u'ğ“¸' : 'o',
    u'ğ“¹' : 'p',
    u'ğ“º' : 'q',
    u'ğ“»' : 'r',
    u'ğ“¼' : 's',
    u'ğ“½' : 't',
    u'ğ“¾' : 'u',
    u'ğ“¿' : 'v',
    u'ğ”€' : 'w',
    u'ğ”' : 'x',
    u'ğ”‚' : 'y',
    u'ğ”ƒ' : 'z',
    u'ğ”„' : 'A',
    u'ğ”…' : 'B',
    u'ğ”‡' : 'D',
    u'ğ”ˆ' : 'E',
    u'ğ”‰' : 'F',
    u'ğ”Š' : 'G',
    u'ğ”' : 'J',
    u'ğ”' : 'K',
    u'ğ”' : 'L',
    u'ğ”' : 'W',
    u'ğ”›' : 'X',
    u'ğ”œ' : 'Y',
    u'ğ”' : 'a',
    u'ğ”Ÿ' : 'b',
    u'ğ” ' : 'c',
    u'ğ”¡' : 'd',
    u'ğ”¢' : 'e',
    u'ğ”£' : 'f',
    u'ğ”¤' : 'g',
    u'ğ”¥' : 'h',
    u'ğ”¦' : 'i',
    u'ğ”§' : 'j',
    u'ğ”¨' : 'k',
    u'ğ”©' : 'l',
    u'ğ”ª' : 'm',
    u'ğ”«' : 'n',
    u'ğ”¬' : 'o',
    u'ğ”­' : 'p',
    u'ğ”®' : 'q',
    u'ğ”¯' : 'r',
    u'ğ”°' : 's',
    u'ğ”±' : 't',
    u'ğ”²' : 'u',
    u'ğ”³' : 'v',
    u'ğ”´' : 'w',
    u'ğ”µ' : 'x',
    u'ğ”¶' : 'y',
    u'ğ”·' : 'z',
    u'ğ”¸' : 'A',
    u'ğ”¹' : 'B',
    u'ğ”»' : 'D',
    u'ğ”¼' : 'E',
    u'ğ”½' : 'F',
    u'ğ”¾' : 'G',
    u'ğ•€' : 'I',
    u'ğ•' : 'J',
    u'ğ•‚' : 'K',
    u'ğ•ƒ' : 'L',
    u'ğ•„' : 'M',
    u'ğ•†' : 'O',
    u'ğ•Š' : 'S',
    u'ğ•‹' : 'T',
    u'ğ•Œ' : 'U',
    u'ğ•' : 'V',
    u'ğ•' : 'W',
    u'ğ•' : 'X',
    u'ğ•' : 'Y',
    u'ğ•’' : 'a',
    u'ğ•“' : 'b',
    u'ğ•”' : 'c',
    u'ğ••' : 'd',
    u'ğ•–' : 'e',
    u'ğ•—' : 'f',
    u'ğ•˜' : 'g',
    u'ğ•™' : 'h',
    u'ğ•š' : 'i',
    u'ğ•›' : 'j',
    u'ğ•œ' : 'k',
    u'ğ•' : 'l',
    u'ğ•' : 'm',
    u'ğ•Ÿ' : 'n',
    u'ğ• ' : 'o',
    u'ğ•¡' : 'p',
    u'ğ•¢' : 'q',
    u'ğ•£' : 'r',
    u'ğ•¤' : 's',
    u'ğ•¥' : 't',
    u'ğ•¦' : 'u',
    u'ğ•§' : 'v',
    u'ğ•¨' : 'w',
    u'ğ•©' : 'x',
    u'ğ•ª' : 'y',
    u'ğ•«' : 'z',
    u'ğ•¬' : 'A',
    u'ğ•­' : 'B',
    u'ğ•®' : 'C',
    u'ğ•¯' : 'D',
    u'ğ•°' : 'E',
    u'ğ•±' : 'F',
    u'ğ•²' : 'G',
    u'ğ•³' : 'H',
    u'ğ•³' : 'I',
    u'ğ•µ' : 'J',
    u'ğ•¶' : 'K',
    u'ğ•·' : 'L',
    u'ğ•¸' : 'M',
    u'ğ•¹' : 'N',
    u'ğ•º' : 'O',
    u'ğ•»' : 'P',
    u'ğ•¼' : 'Q',
    u'ğ•½' : 'R',
    u'ğ•¾' : 'S',
    u'ğ•¿' : 'T',
    u'ğ–€' : 'U',
    u'ğ–' : 'V',
    u'ğ–‚' : 'W',
    u'ğ–ƒ' : 'X',
    u'ğ–„' : 'Y',
    u'ğ–…' : 'E',
    u'ğ–†' : 'a',
    u'ğ–‡' : 'b',
    u'ğ–ˆ' : 'c',
    u'ğ–‰' : 'd',
    u'ğ–Š' : 'e',
    u'ğ–‹' : 'f',
    u'ğ–Œ' : 'g',
    u'ğ–' : 'h',
    u'ğ–' : 'i',
    u'ğ–' : 'j',
    u'ğ–' : 'k',
    u'ğ–‘' : 'l',
    u'ğ–’' : 'm',
    u'ğ–“' : 'n',
    u'ğ–”' : 'o',
    u'ğ–•' : 'p',
    u'ğ––' : 'q',
    u'ğ–—' : 'r',
    u'ğ–˜' : 's',
    u'ğ–™' : 't',
    u'ğ–š' : 'u',
    u'ğ–›' : 'v',
    u'ğ–œ' : 'w',
    u'ğ–' : 'x',
    u'ğ–' : 'y',
    u'ğ–Ÿ' : 'z',
}

UnicodeEscapeMap = {}  ## number : unichar

def _gen_random_id(size=16):
    import random, string
    chars = string.ascii_uppercase + string.digits
    return ''.join(random.choice(chars) for _ in range(size))

class typedpython:
    unicode_vars = USE_UNICODE_VARS
    types = ['string', 'str', 'list', 'dict', 'bool']
    native_number_types = ['int', 'float', 'double']  ## float and double are the same
    simd_types = ['float32x4', 'int32x4']  ## dart
    vector_types = ['float32vec']
    vector_types.extend( simd_types )
    number_types = ['long']  ## requires https://github.com/dcodeIO/Long.js
    number_types.extend( native_number_types )
    types.extend( number_types)
    types.extend( vector_types )

    __whitespace = [' ', '\t']

    GO_SPECIAL_CALLS = {
        'go'         : '__go__',
        'spawn'      : '__go__',
        'channel'    : '__go_make_chan__',
        'go.channel' : '__go_make_chan__',
        'go.array'   : '__go__array__',
        'go.make'    : '__go_make__',
        'go.addr'    : '__go__addr__',
        'go.func'    : '__go__func__',
    }

    @classmethod
    def needs_escape(cls,txt):
        return '__x0s0x__' in txt

    @classmethod
    def escape_text(cls,txt):
        escape_hack_start = '__x0s0x__'
        escape_hack_end = '__x0e0x__'
        parts = []
        chunks = txt.split(escape_hack_start)
        if len(chunks)==1:
            raise RuntimeError('invalid sequence')

        for p in chunks:
            if escape_hack_end in p:
                #if p.endswith( escape_hack_end ):
                id = int(p.split(escape_hack_end)[0].strip())
                assert id in UnicodeEscapeMap.keys()
                uchar = UnicodeEscapeMap[ id ]
                #if '__x0' in uchar:
                #   print UnicodeEscapeMap
                #   raise RuntimeError('bad:'+uchar)
                parts.append(uchar)
                parts.append(p.split(escape_hack_end)[1])
            else:
                #if '__x0' in p:
                #   raise RuntimeError('bad escape:'+p)
                if not p:
                    continue
                    print chunks
                parts.append(p)

        res = ''.join(parts)
        return res.encode('utf-8')


    @classmethod
    def get_indent(cls, s):
        indent = []
        for char in s:
            if char in cls.__whitespace:
                indent.append( char )
            else:
                break
        return ''.join(indent)

    @classmethod
    def transform_source(cls, source, strip=False, allow_tabs_and_spaces=True ):
        output = []
        output_post = None
        asm_block = False
        asm_block_indent = 0
        indent_unit = '' # indent sensitive

        for line in source.splitlines():
            if line.strip().startswith('#'):
                continue

            if asm_block:
                dent = cls.get_indent(line)
                if asm_block==True:
                    asm_block = 'OK'
                    asm_block_indent = len(dent)

                if len(dent) &lt; asm_block_indent:
                    asm_block = False
                    asm_block_indent = 0
                elif len(dent) &gt; asm_block_indent:
                    raise SyntaxError('invalid asm indentation level')
                else:
                    assert len(dent)==asm_block_indent
                    if line.strip():
                        output.append( '%s&quot;%s&quot;' %(dent,line.strip()) )
                    else:
                        asm_block = False
                        asm_block_indent = 0
                    continue

            a = []
            hit_go_typedef = False
            hit_go_funcdef = False
            gotype = None
            isindef = False
            isinlet = False
            inline_wrap = False
            inline_ptr = False
            prevchar = None

            if line.strip().startswith('cdef '):  ## cython syntax ##
                line = line.replace('cdef ', 'cdef(&quot;&quot;&quot;') + '&quot;&quot;&quot;)'

            for i,char in enumerate(line):

                if isindef is False and len(a) and ''.join(a).strip().startswith('def '):
                    isindef = True
                if isinlet is False and len(a) and ''.join(a).strip().startswith('let '):
                    isinlet = True

                nextchar = None
                j = i+1
                while j &lt; len(line):
                    nextchar = line[j]
                    if nextchar.strip(): break
                    j += 1

                if char in MathematicalAlphabet.keys():
                    if USE_UNICODE_VARS or OBFUSCATE_UNICODE:
                        ## note with unicode characters they can not
                        ## be restored wth chr(ord(char))
                        if OBFUSCATE_UNICODE:
                            if char not in ObfuscationMap:
                                ObfuscationMap[ char ] = _gen_random_id()
                            ucord = ObfuscationMap[ char ]
                        else:
                            ucord = ord(char)

                        if ucord not in UnicodeEscapeMap:
                            UnicodeEscapeMap[ ucord ] = char

                        ## escape syntax ##
                        char = '__x0s0x__%s__x0e0x__' % ucord
                    else:
                        char = MathematicalAlphabet[ char ]

                elif ord(char) &gt; 255:
                    if OBFUSCATE_UNICODE:
                        if char not in ObfuscationMap:
                            ObfuscationMap[ char ] = _gen_random_id()
                        ucord = ObfuscationMap[ char ]
                    else:
                        ucord = ord(char)
                    if ucord not in UnicodeEscapeMap:
                        UnicodeEscapeMap[ ucord ] = char
                    char = '__x0s0x__%s__x0e0x__' % ucord

                ##################################

                if prevchar=='=' and char in '&amp;*~':
                    inline_ptr = True
                    a.append('__inline__[&quot;' + char)
                elif inline_ptr and char not in '&amp;*~':
                    inline_ptr = False
                    a.append('&quot;] &lt;&lt; ')
                    a.append( char )

                #elif char == '(' and nextchar in ('&amp;','@'):  ## DEPRECATED
                #   inline_wrap = True
                #   a.append('(inline(&quot;')
                elif char in '),' and inline_wrap:
                    inline_wrap = False
                    for u,_ in enumerate(a):
                        if _=='@':
                            a[u] = 'ref '  ## old rust syntax
                    if char == ')':
                        a.append('&quot;))')
                    else:
                        a.append('&quot;),')

                ## go array and map syntax ##
                #elif (not isindef and not isinlet) and len(a) and char==']' and j==i+1 and nextchar!=None and nextchar in '[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':
                elif not isindef and len(a) and char==']' and j==i+1 and nextchar!=None and nextchar in '[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':
                    assert '[' in a
                    hit_go_typedef = True

                    gotype = []
                    restore = list(a)
                    b = a.pop()
                    while b != '[':
                        gotype.append(b)
                        b = a.pop()
                    gotype.reverse()
                    gotype = ''.join(gotype).strip()  ## fixes spaces inside brackets `[ 1 ]string()`
                    if not gotype:
                        if nextchar=='[':
                            a.append('__go__array__&lt;&lt;')
                        else:
                            a.append('__go__array__(')
                    elif gotype.isdigit():
                        p = ''.join(a).split()[-1].strip()
                        if p.startswith('[') or p.startswith('='):
                            a.append('__go__arrayfixed__(%s,' %gotype)
                        else:
                            hit_go_typedef = False
                            restore.append(char)
                            a = restore

                    elif ''.join(a[-3:])=='map' and gotype != 'func' and a[-4] in cls.__whitespace+['=']:
                        a.pop(); a.pop(); a.pop()
                        a.append('__go__map__(%s,' %gotype)
                    else:
                        hit_go_typedef = False
                        restore.append(char)
                        a = restore

                elif hit_go_funcdef and char==')' and ')' in ''.join(a).split('func(')[-1] and not ''.join(a).strip().startswith('def '):
                    hit_go_funcdef = False
                    a.append('))&lt;&lt;')
                elif hit_go_typedef and char=='(':
                    if ''.join(a).endswith('func'):
                        hit_go_funcdef = True
                        a.append( '(' )
                    else:
                        a.append(')&lt;&lt;(')
                    hit_go_typedef = False
                elif hit_go_typedef and char=='{':
                    a.append(')&lt;&lt;{')
                    hit_go_typedef = False
                elif hit_go_typedef and char==',':
                    #a.append(', type=True),')  ## this breaks function annotations that splits on ','
                    a.append('&lt;&lt;typedef),')
                    hit_go_typedef = False
                elif hit_go_typedef and char in (' ', '\t'):
                    hit_go_typedef = False
                    if isinlet:
                        a.append(')')
                    else:
                        aa = []
                        for xx in a:
                            if xx == '__go__array__(':
                                aa.append('__go__array__[')
                            else:
                                aa.append( xx )
                        a = aa
                        a.append(']=\t\t\t\t')


                elif a and char in cls.__whitespace:
                    b = ''.join(a)
                    b = b.strip()
                    is_class_type = b.startswith('class:') and len(b.split(':'))==2
                    is_pointer = b.startswith('*')
                    is_func = b.startswith('func(') and not ''.join(a).strip().startswith('func(')
                    if (b in cls.types or is_class_type or is_pointer or is_func) and nextchar != '=':
                        if strip:
                            a = a[ : -len(b) ]
                        elif is_class_type:
                            cls = b.split(':')[-1]
                            a = a[ : -len('class:')-len(cls)]
                            a.append('__go__class__[%s]=\t\t\t\t' %cls)

                        elif is_pointer:
                            cls = b.split('*')[-1]
                            a = a[ : -len('*')-len(cls)]
                            a.append('__go__pointer__[%s]=\t\t\t\t' %cls)
                        elif is_func:
                            u = ''.join(a)
                            u = u.replace('func(', '__go__func__[&quot;func(')
                            u += '&quot;]=\t\t\t\t'
                            raise RuntimeError(u)
                            a = [w for w in u]

                        else:
                            #if a[-1]=='*':
                            #   a.pop()
                            #   a.append('POINTER')
                            #a.append('=\t\t\t\t')
                            a.append( char )

                    else:
                        a.append( char )
                else:
                    a.append( char )

                if char.strip():
                    prevchar = char


            c = ''.join(a)
            cs = c.strip()

            if cs.startswith('//'):
                continue
            elif cs.startswith('inline(') or cs.startswith('JS('):
                output.append(c)
                continue


            if cs.startswith('var '):
                c = c.replace('var ', '')

            if cs.startswith('let '):
                mut = False
                if cs.startswith('let mut '):
                    c = c.replace('let mut ', '__let__(')
                    mut = True
                else:
                    c = c.replace('let ', '__let__(')

                if ':' in c:  ## `let x:T`
                    ct = c[ c.index(':')+1 : ].strip()
                    c  = c[ : c.index(':') ]
                    cv = None
                    if '=' in ct:
                        ct, cv = ct.split('=')
                        ct = ct.strip()
                        cv = cv.strip()

                    c += ',&quot;%s&quot;' %ct
                    if cv:
                        c += ',' + cv

                if mut:
                    c += ',mutable=True)'
                else:
                    c += ')'

            ## this conflicts with inline javascript and lua,
            ## TODO make the parser smarter, and skip quoted strings
            #if '= function(' in c:
            #   k = '= function('
            #   a,b = c.split(k)
            #   output.append( '@expression(%s)' %a.strip())
            #   c = 'def __NAMELESS__(' + b

            indent = []
            for char in c:
                if char in cls.__whitespace:
                    indent.append( char )
                else:
                    break
            indent = ''.join(indent)


            if ' except ' in c and ':' in c:  ## PEP 463 - exception expressions
                s = c.split(' except ')
                if len(s) == 2 and '=' in s[0] and ':' in s[1]:
                    s0 = s[0].strip()
                    output.append('%stry: %s' %(indent, s0) )
                    exception, default = s[1].split(':')
                    output.append('%sexcept %s: %s=%s' %(indent, exception, s0.split('=')[0], default) )
                    c = ''

            if not allow_tabs_and_spaces:  ## TODO fixme, this is not safe now because we do not skip quoted text
                indent = len(c) - len(c.lstrip())
                if indent_unit == '' and indent:
                    indent_unit = c[0]
                elif c:
                    if indent and c[0] != indent_unit:
                        raise TabError('inconsistent use of tabs and spaces in indentation in line:', str(i+1) + '\n'+ c)
                    indent = indent_unit*indent

            if ' def(' in c or ' def (' in c:
                if ' def(' in c:
                    a,b = c.split(' def(')
                else:
                    a,b = c.split(' def (')

                if '=' in a:
                    output.append( indent + '@expression(%s)' %a.split('=')[0])
                    c = indent + 'def __NAMELESS__(' + b 



            if c.strip().startswith('def ') and '-&gt;' in c:  ## python3 syntax
                c, rtype = c.split('-&gt;')
                c += ':'
                rtype = rtype.strip()[:-1].strip()
                if rtype.endswith('*') or rtype.endswith('&amp;'):
                    rtype = '&quot;%s&quot;' %rtype
                elif rtype.startswith('[') or rtype.endswith('&gt;'):
                    rtype = '&quot;%s&quot;' %rtype

                if not strip:
                    output.append( indent + '@returns(%s)' %rtype)

            if c.startswith('import '):
                if '-' in c:
                    c = c.replace('-', '__DASH__')
                if '/' in c:
                    c = c.replace('/', '__SLASH__')
                if '&quot;' in c:
                    c = c.replace('&quot;', '')


            if ' new ' in c:
                c = c.replace(' new ', ' __new__&gt;&gt;')
            if '\tnew ' in c:
                c = c.replace('\tnew ', ' __new__&gt;&gt;')

            ## return-block-lambda syntax, helper syntax for c++14 seastar ##
            if c.strip().startswith('return ') and c.strip().endswith(':'):
                c = c.replace('return ', 'with return_')

            ## golang

            if c.strip().startswith('switch '):
                c = c.replace('switch ', 'with __switch__(').replace(':', '):')

            if c.strip().startswith('default:'):
                c = c.replace('default:', 'with __default__:')

            if c.strip().startswith('select:'):
                c = c.replace('select:', 'with __select__:')

            if c.strip().startswith('case ') and c.strip().endswith(':'):
                c = c.replace('case ', 'with __case__(').replace(':', '):')

            if '&lt;-' in c:
                if '=' in c and c.index('=') &lt; c.index('&lt;-'):
                    c = c.replace('&lt;-', '__go__receive__&lt;&lt;')
                else:
                    ## keeping `=` allows for compatible transform to stacklessPython API,
                    ## this is not used now because it is not required by the Go backend.
                    c = c.replace('&lt;-', '= __go__send__&lt;&lt;')
                    #c = c.replace('&lt;-', '&lt;&lt;__go__send__&lt;&lt;')


            ## c++/libpython `-&gt;` gets translated to a CPython C-API call. 
            ## TODO: could also be specialized or other backends, or by user  `with syntax('-&gt;', USER_MACRO):` ##
            if '-&gt;' in c:
                #a,b = c.split('-&gt;')
                #this_name = a.split()[-1].split('=')[-1].split(':')[-1].split(',')[-1]
                #method_name = b.split()[0].split('(')[0]
                #c = c.replace('-&gt;'+method_name, '.__right_arrow__&lt;&lt;'+method_name)

                c = c.replace('-&gt;(', '.__right_arrow__(')
                c = c.replace('-&gt;[', '.__right_arrow__[')
                c = c.replace('-&gt;', '.__right_arrow__.')


            ## python3 annotations
            if 'def ' in c and c.count(':') &gt; 1:
                #head, tail = c.split('(')
                head = c[ : c.index('(') ]
                tail = c[ c.index('(')+1 : ]
                args = []
                #tail, tailend = tail.split(')')
                tailend = tail[ tail.rindex(')')+1 : ]
                tail = tail[ : tail.rindex(')') ]


                for x in tail.split(','):
                    y = x
                    if ':' in y:
                        kw = None
                        if '=' in y:
                            y, kw = y.split('=')
                        #arg, typedef = y.split(':')
                        arg = y[ : y.index(':') ]
                        typedef = y[ y.index(':')+1 : ]
                        typedef = typedef.strip()

                        chan = False
                        T = False
                        if len(typedef.strip().split()) &gt;= 2 and not typedef.startswith('func('):
                            parts = typedef.strip().split()
                            if 'chan' in parts:  ## go syntax
                                chan = True
                            else:                ## rust or c++ syntax
                                T = ' '.join(parts[:-1])

                            #typedef = typedef.strip().split()[-1]
                            typedef = parts[-1]

                        if '*' in arg:
                            arg_name = arg.split('*')[-1]
                        else:
                            arg_name = arg

                        if typedef.startswith('[]'):
                            typedef = '__arg_array__(&quot;%s&quot;)' %typedef.strip()  ## this parses the go syntax and converts it for each backend
                        elif typedef.startswith('['):
                            typedef = '&quot;%s&quot;' %typedef.strip()

                        elif typedef.startswith('map['):
                            typedef = '__arg_map__(&quot;%s&quot;)' %typedef.strip()  ## this parses the go syntax and converts it for each backend

                        elif typedef.endswith('*'):
                            typedef = '&quot;%s&quot;' %typedef.strip()
                        elif typedef.endswith('&amp;'):
                            typedef = '&quot;%s&quot;' %typedef.strip()
                        elif typedef.startswith('func('):
                            typedef = '&quot;%s&quot;' %typedef.strip()
                            if ' ' in typedef or '\t' in typedef:
                                ## TODO deprecate this old pipe-sep hack
                                typedef = '|'.join(typedef.split())

                        elif typedef.startswith('lambda('):
                            typedef = '&quot;%s&quot;' %typedef.strip()
                        elif '::' in typedef:
                            typedef = '&quot;%s&quot;' %typedef.strip()
                        elif '&lt;' in typedef and '&gt;' in typedef: ## rust and c++ template/generics syntax
                            typedef = '&quot;%s&quot;' %typedef.strip()
                        elif ':' in typedef and typedef.strip().startswith('[') and typedef.strip().endswith(']'): ## verilog [bit:index] syntax
                            typedef = '&quot;%s&quot;' %typedef.strip()

                        if not strip:
                            if T:  ## rust or c++ syntax
                                output.append('%s@__typedef__(%s, %s, &quot;%s&quot;)' %(indent, arg_name, typedef, T))
                            elif chan:
                                output.append('%s@typedef_chan(%s=%s)' %(indent, arg_name, typedef))
                            else:
                                output.append('%s@typedef(%s=%s)' %(indent, arg_name, typedef))

                        if kw:
                            arg += '=' + kw
                        args.append(arg)
                    else:
                        args.append(x)
                c = head +'(' + ','.join(args) + ')'+tailend  ## restores to python2 syntax

            #elif '::' in c or ('&lt;' in c and '&gt;' in c and c.count('&lt;')==c.count('&gt;')):  ## c++ syntax `('std::bla&lt;T&gt;')(foo)`
            #   ##  could auto quote here so `(std::&lt;T&gt;)` becomes `('std::&lt;T&gt;')
            #   left = c.index('::')
            #   while c[left]!='`':
            #       left -= 1
            #   if &quot;&gt;`&quot; in c:
            #       c = c.replace(&quot;&gt;`&quot;, &quot;&gt;')&lt;&lt;&quot;)
            #   elif c.endswith('`'):
            #       c = c[:-1] + &quot;')&quot;
            #   c = c[ :left-1 ] + &quot; inline('&quot; + c[left+1:]

            #if '::' in c:
            #   c = c.replace('::', '.__doublecolon__.')
            #   ## this easily breaks - example: &quot;myarray[ ::x]&quot;
            #   ugly = '[.__doublecolon__.'
            #   if ugly in c: c = c.replace(ugly, '[::')
            #   ugly = '.__doublecolon__.]'
            #   if ugly in c: c = c.replace(ugly, '::]')
            #   for n in range(-9, 9):
            #       nasty = '.__doublecolon__.%s]' %n
            #       if nasty in c:
            #           c = c.replace(nasty, '::%s]'%n)

            if c.strip().startswith('with ') and ' as ' in c and c.endswith(':'):
                x,y = c.split(' as ')
                if &quot;'&quot; in y or '&quot;' in y:
                    y = y[:-1] + '[MACRO]:'
                    c = ' as '.join([x,y])
            elif not c.startswith('except ') and ' as ' in c:
                if (c.strip().startswith('return ') or '(' in c or ')' in c or '=' in c or c.strip().startswith('print')):
                    c = c.replace(' as ', '&lt;&lt;__as__&lt;&lt;')
                elif c.strip().startswith('for '):
                    c = c.replace('for ', 'for (').replace(' in ', ') in ').replace(' as ', ',__as__,')


            ## jquery ##
            ## TODO ensure this is not inside quoted text
            #if '$(' in c:
            #   c = c.replace('$(', '__DOLLAR__(')
            #if '$' in c and 'def ' in c:  ## $ as function parameter
            #   c = c.replace('$', '__DOLLAR__')
            #if '$.' in c:
            #   c = c.replace('$.', '__DOLLAR__.')
            if '$' in c:
                c = c.replace('$', '__DOLLAR__')

            if c.strip().startswith('nonlocal '):  ## Python3 syntax
                c = c.replace('nonlocal ', 'global ')  ## fake nonlocal with global

            if c.strip().startswith('with asm('):
                asm_block = True

            if strip and c.strip().startswith('with ('):
                c = c.split('with (')[0] + 'if True:'

            ## regular output
            output.append( c )


        parse_and_fix_code('\n'.join(output), output)
        return '\n'.join(output)


def parse_and_fix_code(r, output):
    try:
        ast.parse(r)
    except SyntaxError as e:
        errmsg = str(e)
        #print errmsg
        eline = output[e.lineno-1]
        echar = None
        echar_prev = None
        if e.offset is not None and e.offset &lt; len(eline):
            echar = eline[ e.offset ]
            echar_next = None
            echar_prev = None
            if e.offset+1 &lt; len(eline):
                echar_next = eline[ e.offset+1 ]
            if e.offset-1 &gt; 0:
                echar_prev = eline[ e.offset-1 ]

        #####################################
        if errmsg.startswith('invalid syntax (&lt;unknown&gt;,') and '.finally(' in eline:
            output[e.lineno-1] = eline.replace('.finally(', '.__finally__(')
            parse_and_fix_code('\n'.join(output), output)

        elif errmsg.startswith('invalid syntax (&lt;unknown&gt;,') and 'then(' in eline:
            if eline.strip().startswith('and then('):
                output[e.lineno-1] = eline.replace('and then(', 'with chain_then(')
                parse_and_fix_code('\n'.join(output), output)

            else:
                nline = []
                hit = False
                for c in eline:
                    if c.strip() and not hit:
                        nline.append('with ')
                        hit = True
                    nline.append(c)
                eline = ''.join(nline)
                output[e.lineno-1] = eline
                parse_and_fix_code('\n'.join(output), output)

        elif errmsg.startswith('invalid syntax') and echar_prev=='.':
            if eline.count('..')==1:
                output[e.lineno-1] = eline.replace('..', '.__doubledot__.')
                parse_and_fix_code('\n'.join(output), output)
            else:
                nline = list(eline)
                nline[ e.offset-1: e.offset+1 ] = '.__doubledot__.'
                output[e.lineno-1] = ''.join(nline)
                parse_and_fix_code('\n'.join(output), output)


        elif errmsg.startswith('invalid syntax') and echar==':' and echar_prev==':':
            if eline.count('::')==1:
                output[e.lineno-1] = eline.replace('::', '.__doublecolon__.')
                parse_and_fix_code('\n'.join(output), output)
            else:
                nline = list(eline)
                nline[ e.offset-1: e.offset+1 ] = '.__doublecolon__.'
                output[e.lineno-1] = ''.join(nline)
                parse_and_fix_code('\n'.join(output), output)


        elif errmsg.startswith('only named arguments may follow *expression'):
            nline = []
            infunc = False
            hitptr = 0
            for i,char in enumerate(eline):
                if char=='(':
                    infunc = True
                elif infunc and char=='*':
                    hitptr += 1
                elif hitptr and (char==',' or char==')'):
                    nline.append('[...]'*hitptr)
                    hitptr = 0
                elif hitptr and char==' ' and i&gt;0 and nline[i-1] != '*':
                    nline.append('[...]'*hitptr)
                    hitptr = 0

                if char=='*' and hitptr:
                    pass
                else:
                    nline.append(char)

            if hitptr:
                nline.append('[...]'*hitptr)

            output[e.lineno-1] = ''.join(nline)
            parse_and_fix_code('\n'.join(output), output)

        elif echar=='(' and '[' in eline and ']' in eline and '=' in eline:
            varname = eline.strip().split()[0].split('=')[0]
            eline = eline.replace('(', ',(').replace(varname, '__array__(%s,'%varname).replace('=','')
            eline = eline.replace('[', '').replace(']', ',')
            earr = list(eline)
            earr.insert( eline.rindex(')'), ')' )
            eline = ''.join(earr)
            output[e.lineno-1] = eline
            parse_and_fix_code('\n'.join(output), output)
        elif echar_prev=='s' and ' as ' in eline:
            output[e.lineno-1] = eline.replace(' as ','&lt;&lt;__as__&lt;&lt;' )
            parse_and_fix_code('\n'.join(output), output)

        else:
            print '-'*80
            print 'Syntax Error on this line:'
            if eline.strip().startswith('def '):
                funcname = eline.strip().split('(')[0].split('def ')[-1]
                print 'SyntaxError in function definition: &quot;%s&quot;' % funcname
                for i,eln in enumerate(r.splitlines()):
                    if 'def '+funcname in eln:
                        print 'line number: %s' %(i+1)
                        print eln
                        if 'func(' or 'lambda(' in eln:
                            if ')(' in eline:
                                print 'note: the syntax for typed callback functions is &quot;func(arg1 arg2)(return_type)&quot;'
                                print 'the arguments are space separated, not comma separated.'
                                print 'example: &quot;func(int int)()&quot; is a callback that takes two ints and returns nothing.'
                                sys.exit(1)
            else:
                print eline
            print '-'*80
            print 'echar: ', echar
            print 'echar-prev: ', echar_prev

            raise e

</code></pre>

<h2 id="simple-syntax-test">Simple Syntax Test</h2>
<pre><code class="python">
__test_typedpython__ = u'''

if True:
    d = a[ 'somekey' ] except KeyError: 'mydefault'

## &lt;- becomes __go__send__&lt;&lt;a
g &lt;- a
## = &lt;- becomes __go__receive__&lt;&lt;b
g = &lt;- b

def call_method( cb:func(int)(int) ) -&gt;int:
    return cb(3)

def wrapper(a:int, c:chan int):
    result = longCalculation(a)
    c &lt;- result

switch a.f():
    case 1:
        print(x)
    case 2:
        print(y)
    default:
        break

select:
    case x = &lt;- a:
        y += x
    case x = &lt;- b:
        y += x



def f(a:int, b:int, c:int) -&gt;int:
    return a+b+c

def f(a:int=100, b:int=100) -&gt;int:
    return a+b

def f(*args:int, **kwargs:int) -&gt;int:
    return a+b

a = []int(x for x in range(3))

y = go.make([]float64, 1000)

def plot(id:string, latency:[]float64, xlabel:string, title:string ):
    pass

def f( x:*ABC ) -&gt; *XXX:
    pass

def listpass( a:[]int ):
    pass

def mappass( a:map[string]int ):
    return ConvertDataUnits[unit_type][unit][1][0]

m = map[int]string{ a:'xxx' for a in range(10)}


functions = map[string]func(int)(int){}
[]int a = go( f() for f in funtions )

## in go becomes: map[string]int{x,y,z}
## becomes: __go__map__(string, int) &lt;&lt; {'x':x, 'y':y, 'z':z}
a = map[string]int{
    &quot;x&quot;:x, 
    &quot;y&quot;:y, 
    &quot;z&quot;:z
}

def f():
    return [[0]]
print f()[0][0]

## in go becomes: []string{x,y,z}
## becomes: __go__array__(string) &lt;&lt; (x,y,z)
a = []string(x,y,z)

## in go becomes: [3]int{x,y,z}
## becomes: __go__arrayfixed__(3, string) &lt;&lt; (x,y,z)
a = [ 3 ]int(x,y,z)

## Rust - DEPRECATED (replaced by minimacro with syntax)
## f(inline('&amp;mut *x'))
#f(&amp;mut *x)
## f(inline('ref mut *x'), y.z())
#f(@mut *x, y.z())


## f(x &lt;&lt; __as__ &lt;&lt; uint)
f(x as uint)

## __let__[x :&quot; Vec&lt;(uint, Y&lt;int&gt;)&gt; &quot;]= range(0,1).map().collect()
let x : Vec&lt;(uint, Y&lt;int&gt;)&gt; = range(0,1).map().collect()
let i
i = &amp;**x

def f(a:&amp;mut int) -&gt;int:
    return a

def f():
    with asm( outputs=b, inputs=a, volatile=True ):
        movl %1, %%ebx;
        movl %%ebx, %0;
    return x

let mut x : int = 1
let x : int
def __init__():
    let self.x : int = x
    let mut self.y : int = y


def call_method( cb:lambda(int)(int) ) -&gt;int:
    return cb(3)

if self.__map[r][c] in (WALL,PERM_WALL): pass

## allow func to be used as a function name, because it is pretty commom and allowed by most backends.
def func(x=None, callback=None):
    func( callback=xxx )
    x.func( xx=yy )

let mut x = 0

def templated( x : Type&lt;T&gt; ):
    pass
def templated( x : namespace::Type&lt;T&gt; ):
    pass

c.x[0] = def(xx,yy) -&gt;int:
    return xx+yy

mdarray = [][]int()
def F() -&gt;[][]int:
    pass

def f():
    return A as B

print `std::chrono::duration_cast&lt;std::chrono::microseconds&gt;`clock().count()

with (some, stuff):
    pass
def f():
    let x : map[string]int = {}

'''

def test_typedpython():
    out = typedpython.transform_source(__test_typedpython__)
    print(out)
    import ast
    print( ast.parse(out) )

</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../intermediateform/" class="btn btn-neutral float-right" title="PreTranslator">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../cpptranslator/" class="btn btn-neutral" title="C++Translator"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/secureosv/pythia" class="icon icon-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../cpptranslator/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../intermediateform/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

</body>
</html>
